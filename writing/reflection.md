# Reflection by Declan Casey, Noor Buchi, Pedro Carmo, Nolan Thompson

## Overview of the source code and terminal commands that you used
In our coding process, we used three main Gradle commands in our terminal. The first command is `gradle run` which runs the main method in `MainApp.java` file. When this command is typed in the terminal, the program runs and the user is prompted for input. Additionally, the program displays output based on what the user chooses. Getting this command to run properly required us to access the gradle files and add the correct class directory. Additionally we had to make sure that classes were packaged and imported. Another command used was `gradle build`, which compiled the program and showed if there are any errors. It also displayed checkstyle issues and helped us in fixing them by pointing out the type of issue. Overall, this command was useful in helping us organize the program to meet Google's standards in coding Java. The last command used was `gradle test`. Although it was not used until JUnit test cases were fully implemented, it helped us make sure that the sorting methods are working properly as expected and returning correct output. In order to get this command to work, changes had to be made to the `build.gradle` file to allow the use of JUnit test suite. Aside from the commands used in the terminal windows, we looked back at some of the laboratory assignments where we reused some of the code there.

## Description of the challenges that you faced and how you resolved them
The main challenge at the beginning of this project was ensuring that all the classes are connected together and to the `MainApp` class where our main method exists. In order to do that, we had to make some changes to the directory of the main class in the gradle files. Reading through the gradle files was part of that challenge because we never had to do that in out class projects. After asking some of the technical leaders and comparing the files to previous projects, we understood what needs to be changed for the program to work. Changing the gradle files allowed us to connect all of the classes and implement the necessary JUnit test suite.

## Description of the way in which you and your team members shared the project work
Since the beginning of this project, each member contributed in many different ways. Whether in coming up with an idea, helping with implementation, or suggesting a new feature, everyone had insight and gave feedback on the project. To allow for this collaboration, we arranged frequent meetings where we discussed our progress and created a plan on how to complete the remaining tasks. Additionally, we attempted to use the branch features of github to organize our work and facilitate working in a team, but we later decided to go back to the method used in class because we were more familiar with it. Overall, this project helped us collaborate and communicate to create a functioning and useful program.

- Noor: My contribution to this project includes implementing the important `printWithSymbol` method that allowed us to explain the sorting algorithm as well as writing the JUnit test suite. I also worked with Declan on writing the proper explanation for every step of sorting as well as finding bugs and issues in the program. Additionally, Nolan and I collaborated in fixing the checkstyle issues in the project as well as completing the technical writing. Overall, each one of us had an important role in completing this project and ensuring that it is working without any issues.

- Nolan: For contributing to this project I implemented most of the structure for the main method. I had it take in info from the user and then generate a random array then based on the users input sends the array to a certain class sorting the said array and showing how the array got sorted. I also helped fix checkstyle errors with Noor in the code, as we had over one-hundred different checkstyle errors across the program. To provide additional help I completed the update reflection file along with two parts of the report reflection.

- Declan: For this project I ended up focusing on the different sorting methods and classes we wanted to implement, as well as making our program's interface easy to interact with and understand. For sorting, I focused on building the selection sort class and it's own sorting method. This was pretty tricky because we had to make this method compatible with our 'printWithSymbol()' method, which origianlly only worked for bubble and insertion sort. Selection sort dealt with splitting the list of numbers into two different arrays, finding the minimum in the unsorted array and then placing it in its correct spot in the sorted array. Noor and I also spent a lot of time focusing on where to print the instructions for each sorting method, whether inside or outside the for loops, as well as making sure the instructions were clear and easy to understand.

- Pedro: For the project I worked on implementing the first version of the explanation for the sorting, `sortExplain` which printed the steps of the sorting method as the sorting occurred, `sortExplain` ended up as `printWithSymbol` in the final version. I also worked on the Bubble sort implementation and testing before we had actual test cases and tested the accuracy of the sorter with "hard-coded" arrays to ensure it worked. We all worked together to fix our issues with GitHub which was confusing due to the code not being pushed correctly.
